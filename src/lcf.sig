(* This signature should by the user of the logic. It requires them
 * to specify the structure of targets of the tactics (what they should
 * operate on, as well as what counts as evidence for having proven one.
 *
 * The tactics library is completely agnostic to how the underlying goals
 * and evidence are structured.
 *)
signature LCF =
sig
  (* The type of the target to prove *)
  type goal
  (* The type of evidence that we've succeeded in proving a goal *)
  type evidence

  (* A validation is the proof a tactic returns of its correctness
   * It maps the evidence of the subgoals the theorem produced and
   * gives back evidence for the original goal it was working on.
   *)
  type validation = evidence list -> evidence

  (* A tactic maps a goal to a list of subgoals and a validation. The
   * outputs are supposed to cohere in that the evidence generated by
   * proving the subgoals can be fed to the validation to produce
   * evidence for the input goal
   *)
  type tactic = goal -> goal list * validation

  (* The user must provide a serialization function for goals in
   * order to support XXXX WHY XXX
   *)
  val goalToString : goal -> string
end

(* If goals have an apartness relation, then we may express
 * the notion of "progress".
 *)
signature LCF_APART =
sig
  include LCF

  (* Are two goals different in a meaningful sense. *)
  val goalApart : goal * goal -> bool
end
